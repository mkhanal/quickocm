<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>QuickOCM by mkhanal</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>QuickOCM</h1>
        <p>Object CSV Mapper for Java</p>
        <p class="view"><a href="https://github.com/mkhanal/quickocm">View the Project on GitHub <small>mkhanal/quickocm</small></a></p>
        <ul>
          <li><a href="https://github.com/mkhanal/quickocm/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/mkhanal/quickocm/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/mkhanal/quickocm">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>QuickOCM - Parse and convert your CSV files to your models in your java application.</p>

<h2>
<a name="features" class="anchor" href="#features"><span class="octicon octicon-link"></span></a>Features</h2>

<ol>
<li>Significance of <strong>header</strong> in CSV.</li>
<li>
<strong>Annotation based</strong>, annotate your models with header-name, datatype, nested model structure.</li>
<li>Supports <strong>nested object</strong> compositions in the models.</li>
<li>Treats each record of the CSV as a model and will invoke user designated handler for each row i.e. model.</li>
<li>
<strong>Validation</strong> of the data-types in CSV automatically handled.</li>
</ol><h2>
<a name="getting-started" class="anchor" href="#getting-started"><span class="octicon octicon-link"></span></a>Getting Started</h2>

<p>Assume your CSV, (first line are headers)</p>

<pre><code>user name   , age   , Date Of JOiNinG , Referrer Code, Street Name  , House No, City
phillips    , 23    , 19/09/1999      , referrer1    , south street , 12      , Timbak 1
sri krishna , 25    , 20/12/2012      , referrer2    , north street , 24      , Timbak 2
Jaquiline   , 44    ,                 , referrer3    , east street  , 36      , Timbak 3
Who so ever , 20000 , 22/02/2010      , referrer4    , west street  , 48      , Timbak 4
</code></pre>

<p>To parse this, you need :
  <ul>
    <li>An equivalent Model 
    <li>Annotations @ImportField and @ImportFields over corresponding fileds.
    <ol>
      <li>Default constructor.
      <li>Setters for fields to be set.
    </ol>
    If your model User is composed of Address, you can see how nested values are being resolved. 
    
</p>

<pre><code>public class User {
  //Getter, Setter, Default Constructor
  @ImportField(mandatory = true, name = "User Name", type = "String")
  private String name;

  @ImportField(mandatory = true, type = "int") //default -> header name = field name
  private Integer age;

  @ImportField(type = "Date", name = "date of joining") //case insensitive headers
  private Date joiningDate;

  @ImportField(type = "String", name = "Referrer Code", nested = "code")
  private Referrer referrer;

  @ImportFields(importFields = {
    @ImportField(type = "String", name = "Street Name", nested = "streetName"),
    @ImportField(type = "int", name = "House No", nested = "houseNo"),
    @ImportField(type = "String", name = "City", nested = "city")})
  private Address completeAddress;

  private String createdBy; //logged in user not present in csv file, can be pulled from session
}

public class Referrer {
    //Getter, Setter, Default Constructor
    private String code;
}

public class Address {
    //Getter, Setter, Default Constructor
    private Integer houseNo;
    private String streetName;
    private String city;
}

</code></pre>

<p>For each row in CSV, your handler will be invoked. So create a handler</p>

<pre><code>public class UserRecordHandler implements RecordHandler&lt;User&gt; {
  //Getter
  private List&lt;User&gt; uploadedUsers = new ArrayList&lt;User&gt;();

  @Override
  public void execute(User user, int i, Map map) {
    user.setCreatedBy((String) map.get("loggedInUser"));
    uploadedUsers.add(user);
  }
}
</code></pre>

<p>This is it. The below code shows a simple test</p>

<pre><code>
public class UserRecordHandlerTest {

  private CsvParser&lt;User&gt; csvParser;

  @Before
  public void setUp() throws Exception {
    Map&lt;String, String&gt; supplementaryInfo = new HashMap&lt;String, String&gt;() {{
      put("loggedInUser", "User123");
    }};

    csvParser = new CsvParser&lt;User&gt;(supplementaryInfo);
  }

  @Test
  public void shouldParseCsvFileAndGetAllUsers() throws Exception {
    String csvContent =
        "User Name  , Age  , Date Of JOiNinG, Referrer Code, Street Name , House No, City\n" +
        "phillips   , 23   , 19/09/1999     , referrer1    , south street, 12      , Timbak 1\n" +
        "sri krishna, 25   , 20/12/2012     , referrer2    , north street, 24      , Timbak 2\n" +
        "Jaquiline  , 44   ,                , referrer3    , east street , 36      , Timbak 3\n" +
        "Who so ever, 20000, 22/02/2010     , referrer4    , west street , 48      , Timbak 4";

    InputStream inputStream = new ByteInputStream(csvContent.getBytes(), csvContent.length());
    UserRecordHandler userRecordHandler = new UserRecordHandler();

    csvParser.process(inputStream, User.class, userRecordHandler);

    SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");

    List&lt;User&gt; uploadedUsers = userRecordHandler.getUploadedUsers();
    assertEquals(4, uploadedUsers.size());<br/>
    assertThat(uploadedUsers.get(0), isSameUser(new User(
    "phillips", 23, format.parse("19/09/1999"), "referrer1", "south street", 12, "Timbak 1", "User123")));<br/>
    assertThat(uploadedUsers.get(1), isSameUser(new User(
    "sri krishna", 25, format.parse("20/12/2012"), "referrer2", "north street", 24, "Timbak 2", "User123")));<br/>
    assertThat(uploadedUsers.get(2), isSameUser(new User(
    "Jaquiline", 44, null, "referrer3", "east street", 36, "Timbak 3", "User123")));<br/>
    assertThat(uploadedUsers.get(3), isSameUser(new User(
    "Who so ever", 20000, format.parse("22/02/2010"), "referrer4", "west street", 48, "Timbak 4", "User123")));<br/>
  }
}

</code></pre>
<p>The code shows that for each record, how the record handler was executed with the Object in question. Also note how extra information like audit info was passed through supplementaryInfo map</p>
      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/mkhanal">mkhanal</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>