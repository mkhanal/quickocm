{"name":"QuickOCM","tagline":"Object CSV Mapper for Java","body":"QuickOCM - Parse and convert your CSV files to your models in your java application.\r\n\r\n## Features\r\n1. Significance of **header** in CSV.\r\n1. **Annotation based**, annotate your models with header-name, datatype, nested model structure.\r\n1. Supports **nested object** compositions in the models.\r\n1. Treats each record of the CSV as a model and will invoke user designated handler for each row i.e. model.\r\n1. **Validation** of the data-types in CSV automatically handled.\r\n\r\n## Getting Started\r\n\r\nAssume your CSV, (first line are headers)\r\n```\r\nuser name   , age   , Date Of JOiNinG , Referrer Code, Street Name  , House No, City\r\nphillips    , 23    , 19/09/1999      , referrer1    , south street , 12      , Timbak 1\r\nsri krishna , 25    , 20/12/2012      , referrer2    , north street , 24      , Timbak 2\r\nJaquiline   , 44    ,                 , referrer3    , east street  , 36      , Timbak 3\r\nWho so ever , 20000 , 22/02/2010      , referrer4    , west street  , 48      , Timbak 4\r\n```\r\n\r\nTo parse this, your model must extend importable. If your model User is composed of Address, you can see how nested values are being resolved. Notice all work is being done using the annotations @ImportField and @ImportFields. You need a default constructor for initialization. However, the objects this primary object do not have these restriction except for setters on the desired fields.\r\n\r\n```\r\npublic class User implements Importable {\r\n  // Add getters and Setters. Setters are required to fill in values\r\n  // equals and hashcode for comparision in test\r\n\r\n  @ImportField(mandatory = true, name = \"User Name\", type = \"String\")\r\n  private String name;\r\n\r\n  @ImportField(mandatory = true, type = \"int\") //default header name = field name\r\n  private Integer age;\r\n\r\n  @ImportField(type = \"Date\", name = \"date of joining\") //case insensitive headers\r\n  private Date joiningDate;\r\n\r\n  @ImportField(type = \"String\", name = \"Referrer Code\", nested = \"code\")\r\n  private Referrer referrer;\r\n\r\n  @ImportFields(importFields = {\r\n    @ImportField(type = \"String\", name = \"Street Name\", nested = \"streetName\"),\r\n    @ImportField(type = \"int\", name = \"House No\", nested = \"houseNo\"),\r\n    @ImportField(type = \"String\", name = \"City\", nested = \"city\")})\r\n  private Address completeAddress;\r\n\r\n  public User() {\r\n  }\r\n\r\n  public User(String name, Integer age, Date joiningDate,\r\n              String referrerCode, String streetName,\r\n              Integer houseNo, String city) {\r\n    this.name = name;\r\n    this.age = age;\r\n    this.joiningDate = joiningDate;\r\n    this.referrer = new Referrer();\r\n    this.referrer.setCode(referrerCode);\r\n    this.completeAddress = new Address();\r\n    completeAddress.setCity(city);\r\n    completeAddress.setHouseNo(houseNo);\r\n    completeAddress.setStreetName(streetName);\r\n  }\r\n}\r\n\r\npublic class Referrer {\r\n    // Getter and Setter\r\n    private String code;\r\n}\r\n\r\n\r\npublic class Address {\r\n    //Getter and Setter\r\n    private Integer houseNo;\r\n    private String streetName;\r\n    private String city;\r\n}\r\n\r\n```\r\n\r\nFor each row in CSV, your handler will be invoked. So create a handler\r\n\r\n```\r\npublic class UserRecordHandler implements RecordHandler<User> {\r\n    //Getter\r\n    private List<User> uploadedUsers = new ArrayList<User>();\r\n\r\n    @Override\r\n    public void execute(User user, int rowNumber) {\r\n        uploadedUsers.add(user);\r\n    }\r\n\r\n}\r\n```\r\n\r\nThis is it. The below code shows a simple test\r\n\r\n```\r\npublic class UserUploadTest {\r\n  @Test\r\n  public void shouldUploadUserCsv() throws Exception {\r\n    CSVParser csvParser = new CSVParser();\r\n    UserRecordHandler userRecordHandler = new UserRecordHandler();\r\n    InputStream inputStream = new FileInputStream(\"user-upload.csv\");\r\n\r\n    csvParser.process(inputStream, User.class, userRecordHandler);\r\n\r\n    List<User> uploadedUsers = userRecordHandler.getUploadedUsers();\r\n    assertThat(uploadedUsers.size(), is(4));\r\n    assertThat(uploadedUsers.get(0), is(new User(\r\n      \"phillips\", 23, getDate(\"19/09/1999\"), \"referrer1\", \"south street\", 12, \"Timbak 1\")));\r\n    assertThat(uploadedUsers.get(1), is(new User(\r\n      \"sri krishna\", 25, getDate(\"20/12/2012\"), \"referrer2\", \"north street\", 24, \"Timbak 2\")));\r\n    assertThat(uploadedUsers.get(2), is(new User(\r\n      \"Jaquiline\", 44, null, \"referrer3\", \"east street\", 36, \"Timbak 3\")));\r\n    assertThat(uploadedUsers.get(3), is(new User(\r\n      \"Who so ever\", 20000, getDate(\"22/02/2010\"), \"referrer4\", \"west street\", 48, \"Timbak 4\")));\r\n  }\r\n\r\n  private Date getDate(String dateString) {\r\n    DateTimeFormatter formatter = DateTimeFormat.forPattern(\"dd/MM/yyyy\");\r\n    return parse(dateString, formatter).toDate();\r\n  }\r\n}\r\n```\r\n\r\n\r\nThe code shows that for each record, how the record handler was executed with the Object in question.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}